\documentclass[a4paper,11pt]{article}



%% Paquetes Adicionales %%

\usepackage[spanish]{babel}
\selectlanguage{spanish}
\usepackage{fancyhdr}
\usepackage[dvips]{graphicx}
\usepackage[normal]{caption2}
\usepackage{amsfonts,amssymb,amsmath,amsthm}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{moreverb}


%% Declaracion de comandos %%

\newtheorem{lema}{Lema}
\newtheorem{teor}{Teorema}
\newtheorem{propos}{Proposici\'on}
\newtheorem{corol}{Corolario}


\newcommand{\mivec}[1]{\mathbf{#1}}
\newcommand{\vers}[1]{\mivec{\check{#1}}}
\newcommand{\deriv}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\expo}[1]{~10^{#1}}
\newcommand{\uni}[1]{\mathrm{#1}} 

\newcommand{\prop}[1]{\begin{propos} #1 \end{propos}}
\newcommand{\teo}[1]{\begin{teor} #1 \end{teor}}
\newcommand{\cor}[1]{\begin{corol} #1 \end{corol}}
\newcommand{\lem}[1]{\begin{lema} #1 \end{lema}}


%% Encabezado y Pie de Pagina %%

\pagestyle{fancy}
\lhead{Criptografía y Seguridad}
\chead{}
\rhead{ITBA}
\cfoot{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

%% Titulo %%
\title{{\bf Sistema de voto electrónico}}
\author{M. Besio \and P. García \and E. Gómez Balaguer \and H. Rajchert}
\date{}

%% Comienzo del documento %%

\begin{document}
\maketitle
\thispagestyle{fancy}

%% COMIENZO DEL TEXTO %%

\section{Introducción}

En este trabajo analizamos el diseño e implementación de un sistema de voto electrónico. El mismo garantiza requerimientos de seguridad mediante el uso de primitivas criptográficas, conformando un protocolo.

\section{Diseño}

Para poder garantizar el anonimato de los votos en el sistema, planteamos el diseño separado en tres subsistemas. Con esto, logramos que en ninguna de las tres partes en ningún momento se encuentre la información suficiente para que se pueda asociar un voto con un votante. Estos tres subsistemas son:

\begin{itemize}
\item Votante: Esta es la terminal en que el usuario vota. Tiene que ser de su confianza.
\item Mesa: Se encarga de validar que cada votante esté registrado en el padrón, y le da un grupo de boletas para que envíe la que corresponda a su elección a la urna.
\item Urna: Tiene como función recibir los votos y entrega al votante el comprobante de votación (ticket).
\end{itemize}

Este esquema puede apreciarse en la figura \ref{esquema}. Allí también se indica con flechas el envío de mensajes entre subsistemas y el orden de los mismos.

\begin{center}
\begin{figure}
\includegraphics[scale=0.70]{esquema}
\caption{Esquema del sistema. Se indica con flechas el envío de mensajes entre subsistemas.}
\label{esquema}
\end{figure}
\end{center}

\subsection{Hipótesis}

Partimos de las siguientes hipótesis:
\begin{itemize}
\item Todos los votantes poseen claves públicas y privadas. 
\item Se puede relacionar los DNI de los votantes con su clave pública.
\item Todos los votantes conocen las claves públicas de los subsistemas.
\item Cada opción de voto (partidos, listas, etc.) posee una clave pública y una privada. La pública es conocida por todos.
\item La lista de opciones de voto es pública.
\item Los administradores de mesa y urna son distintos y no tienen manera de contactarse entre sí (no pueden confabular para modificar los resultados). De no cumplirse esta hipótesis el sistema sería muy fácilmente vulnerable ya que a través del entrecruzamiento de los datos que posee cada subsistema se podría relacionar un voto con su respectivo votante.
\end{itemize}

\subsection{Protocolo}

Con el fin de analizar el protocolo, adoptamos las siguientes convenciones:

\begin{itemize}
\item $U_M$: Clave pública del subsistema \emph{Mesa}.
\item $R_M$: Clave privada del subsistema \emph{Mesa}.
\item $U_U$: Clave pública del subsistema \emph{Urna}.
\item $R_U$: Clave privada del subsistema \emph{Urna}.
\item $U_{V_i}$: Clave pública del i-ésimo votante.
\item $R_{V_i}$: Clave privada del i-ésimo votante.
\item $S_{{VU}_i}$: Secreto compartido entre el i-ésimo votante y la urna.
\item $S_{{VM}_i}$: Secreto compartido entre el i-ésimo votante y la mesa.
\item $\text{DNI}$: Documento Nacional de Identidad del votante. Es su clave identificatoria.
\item $\text{ID}_V$: El ID de votación es una cadena que identifica la votación (única por elección).
\end{itemize}

Un proceso de votación consta de los siguientes 7 pasos:

\subsubsection{Paso 1}
\begin{scriptsize}
\begin{equation}
\text{Votante} \rightarrow \text{Mesa}: U_M \biggl[ U_U \left( S_{{VU}_i} \right) +  S_{{VM}_i} + U_{V_i} + R_{V_i} \Bigl[ \text{DNI}+ \text{ID}_V + \text{Hash} \Bigl( U_U \left( S_{{VU}_i} \right) + S_{{VM}_i}\Bigr) \Bigr]\biggr] 
\end{equation}
\end{scriptsize}


Para ir a votar, la persona le envía al subsistema \emph{Mesa} el siguiente mensaje encriptado con $U_M$ para que sólo la mesa pueda saber su contenido, que consta de:
\begin{itemize}
 
\item Un secreto compartido entre la persona y la urna. Para hacer esto el votante genera un valor aleatorio (como él lo genera, lo conoce) y lo encripta con la clave pública de la urna, para que sólo esta pueda entenderlo. Este secreto va a ser utilizado por la urna para identificar al votante como válido.

\item Un secreto compartido entre la persona y la mesa. Al igual que en el anterior, este secreto es generado por la persona. Sirve para garantizarle a la mesa que el \textbf{hash} siguiente está bien formado y para evitar que la urna
pueda relacionar $S_{{VU}_i}$ con el DNI de la persona.

\item La clave pública de la persona. Es un primer intento de identificación. En este punto la mesa puede buscar en el padrón el DNI que corresponde a la clave suministrada.

\item Su DNI concatenado con el ID de la votación y un \textbf{hash}, y firmado con su clave privada. La mesa ya sabe qué DNI tiene que obtener por el ítem anterior, y como está firmado con $R_{V_i}$ sabe que sólo pudo haber sido creado por la persona. El ID sirve para que no se pueda utilizar el token en otra votación. El hash sirve para evitar que la mesa trate de generar su propio $S_{{VU}_i}$ (ver Sección \ref{mesa_gen_voto}). La mesa tiene que guardar este token completo a modo de comprobante de voto y la persona tiene que guardar $S_{{VU}_i}$  y $S_{{VM}_i}$ como la primera parte de su ticket.


%\item Su ticket, que está compuesto por el DNI de la persona, concatenado con un string aleatorio y encriptado con su clave pública. El ticket es algo que sólo la persona puede llegar a entender y le va a servir para averiguar si su voto está presente cuando se haga el conteo. Posteriormente, ese ticket será firmado digitalmente por la urna y por la mesa para que tenga validez.
\end{itemize}

\subsubsection{Paso 2}

\begin{footnotesize}
\begin{equation}
\text{Mesa} \rightarrow \text{Urna}: U_U \Bigl( R_M \bigl( U_U \left( S_{{VU}_i} \right) + \text{ID}_V \bigr) \Bigr)
\end{equation}
\end{footnotesize}

Después de verificar que la persona está registrada en el padrón y que no votó, la mesa le envía a la urna el secreto $ U_U \left( S_{{VU}_i} \right)$ concatenado al ID de votación, firmado con su clave privada $R_M$. De esta manera la mesa está diciendo que si bien no sabe el secreto, la persona que lo emitió está autorizada para votar (en la votación asignada al ID correspondiente).

\subsubsection{Paso 3}

\begin{footnotesize}
\begin{equation} \label{Math_boletas}
\text{Mesa} \rightarrow \text{Votante}: U_{V_i} \left( \text{Boletas} \right)
\end{equation}
\end{footnotesize} 

\begin{footnotesize}
\begin{equation}
\text{Boletas} = \sum_{i=0}^n R_M \left(\text{Opc}_i + \text{ID}_V + \text{RandA}_i \right)
\end{equation}
\end{footnotesize}
\\


La mesa le devuelve encriptada con $U_{V_i}$ (para que sólo la persona lo entienda) las distintas opciones que puede elegir, es decir, las boletas. Cada boleta está representada por la opción concatenada al ID de votación y a una cadena aleatoria. Están firmadas por la mesa para evitar que otra persona pueda generar una boleta válida.

\subsubsection{Paso 4}

\begin{footnotesize}
\begin{equation}
\text{Votante} \rightarrow \text{Urna}: U_U \left( S_{{VU}_i} + \text{Sobre} \right)
\end{equation}
\end{footnotesize}

\begin{footnotesize}
\begin{equation}
\text{Sobre} = U_{L_1} \circ U_{L_2} \circ \cdots \circ U_{L_n}\bigl( R_M \left(\text{Opc}_i + \text{ID}_V + \text{RandA}_i \right) + \text{RandB}_i  \bigr) 
\end{equation}
\end{footnotesize}

El votante elije uno de las boletas recibidas en el paso 3 y genera un sobre encriptando con las claves públicas de todas las opciones de voto (cada una de ellas representa una opción en la boleta). La boleta elegida se concatena con un valor aleatorio $\text{RandB}_i$ para evitar que la mesa pueda regenerar todos los posibles sobres y saber a quién votó la persona.

Una vez generado el sobre, el votante procede a depositarlo (enviarlo) en la urna. Para hacerlo tiene que enviar (además del sobre) el secreto que sólo él y la urna conocen. La urna puede verificar que el secreto está autorizado por la mesa y marcar internamente que ese secreto está en proceso de votación (para evitar que se pueda votar más de una vez en la misma votación).

\subsubsection{Paso 5}

\begin{footnotesize}
\begin{equation}
\text{Urna} \rightarrow \text{Mesa}: U_M \bigl( U_U \left( S_{{VU}_i} \right) + \text{Challenge} \bigr)
\end{equation}
\end{footnotesize}

Despúes de almacenar el voto, la urna informa a la mesa que la persona ya votó en esta votación (para evitar que vuelva a votar) dándole $U_U \left( S_{{VU}_i} \right)$ que es el valor que la mesa utilizó para relacionar al votante. También le envía un \emph{Challenge} para que la mesa le devuelva firmado a modo de reconocimiento de voto. 


\subsubsection{Paso 6}
\begin{footnotesize}
\begin{equation}
\text{Mesa} \rightarrow \text{Urna}: U_U \bigl( R_M \left( \text{Challenge} \right) \bigr) 
\end{equation}
\end{footnotesize}

La mesa guarda como comprobante el siguiente par de datos:
\begin{footnotesize}
\begin{itemize}
 \item $U_{V_i}$
 \item $R_{V_i} \Bigl[ \text{DNI} + \text{ID}_V + \text{Hash} \bigl( U_U \left( S_{{VU}_i} \right) + S_{{VM}_i}\bigr) \Bigr]$.
\end{itemize}
\end{footnotesize}

Luego firma y le devuelve el \emph{Challenge} a la urna. Ambos marcan que la persona ya votó en la votación correspondiente.


\subsubsection{Paso 7}

\begin{footnotesize}
\begin{equation}
\text{Urna} \rightarrow \text{Votante}: R_U \bigl( \text{Hash} \left( \text{Sobre}\right) \bigr) 
\end{equation}
\end{footnotesize}

%La urna firma el ticket previamente firmado por la mesa y se lo envía al votante (como comprobante de la operación).
Después de recibir el \emph{Challenge} firmado la urna, la urna le aplica una función de hash al sobre recibido en el Paso 4, lo firma y se lo devuelve al votante, que lo utilizará como segunda parte de su ticket.

\section{Conteo y detección de fraude}
El conteo debe ser realizado en un host en el cual confíen todas las listas. La urna debe presentar los sobres y la mesa la lista con comprobantes de voto. Para abrir los sobres cada lista tiene que ingresar su clave privada. El conteo se realiza utilizando las cadenas $R_M \left(\text{Opc}_i + \text{ID}_V + \text{RandA}_i \right)$, que como fueron firmadas por la mesa garantizan la validez del sobre. 
Los partidos tienen que publicar dos listas, una con todos los $\text{Hash} \bigl( U_U \left( S_{{VU}_i} \right) + S_{{VM}_i}\bigr)$ obtenidos de los comprobantes de la mesa y otro con todos los $\text{Hash} \left( \text{Sobre}\right)$ obtenidos de los sobres de la urna. De esta manera cada votante puede buscar su ticket en las listas y verificar que realmente participó en la votación sin revelar a quién votó.

% Si una persona tiene un ticket firmado por la urna y la mesa y su ticket no está en la lista, quiere decir que su voto no ha contado. De esta manera se puede detectar fraude.

A continuación presentamos los distintos escenarios de ataque organizados por el sistema comprometido. Se puede notar que la votación puede ser anulada por la mesa o por la urna, lo que se trata de lograr es identificar quién fue el responsable del fraude.

\subsection{Ataques cometidos por la Mesa}
\subsubsection{Utilizar información de un votante para otras elecciones}
El comprobante que tiene la mesa (recibido en el paso 1) contiene un ID de votación, y está firmado por el votante. Es por eso que la mesa no puede generar un nuevo comprobante válido para otra elección y sin comprobante se puede demostrar que la mesa hizo fraude.

\subsubsection{Sacar un votante de la lista de comprobantes de voto}
Si la mesa elimina un comprobante, la urna tendría más \mbox{$R_M \bigl( U_U \left( S_{{VU}_i} \right) + \text{ID}_V \bigr)$} que comprobantes de voto. Como está firmado por la mesa, la urna no puede generarlos y de esta manera se pueden contar todos los comprobantes de ambas partes y ver quién está cometiendo fraude.

\subsubsection{Generar votos inválidos}\label{mesa_gen_voto}
La mesa puede generar un $S_{{VU}_i}$, encriptarlo con la clave pública de la urna y firmarlo para generar un sobre, pero no puede generar los comprobantes del tipo $U_{V_i}$, $R_{V_i} \Bigl[ \text{DNI}+ \text{ID}_V + \text{Hash} \Bigl( U_U \left( S_{{VU}_i} \right) + S_{{VM}_i}\Bigr) \Bigr]$ para sustentar el voto (porque utilizan la clave privada de cada votante).

\subsubsection{Identificar a un votante con un sobre}
Si no fuese por $\text{RandB}_i$, la mesa podría generar un hash de sobre para cada boleta que emitió en el paso 3 y probar si aparece en el archivo publicado por las listas.

\subsubsection{Anular las elecciones}
La mesa no puede decirle a un votante que ya votó en una elección en que el votante no haya votado porque tendría que tener un comprobante que respalde esa afirmación.
Si la mesa está fuera de servicio o si decide no contestar mensajes de los votantes, las personas que decidan votar no van a poder y les va a aparecer un mensaje para que planteen una queja a las autoridades, pero esto no anula las elecciones (ver restricciones del protocolo).

\subsection{Ataques cometidos por la urna}

\subsubsection{Modificar un voto}\label{modif_voto}
La urna no puede generar un sobre válido, porque la opción tiene que estar firmada por la mesa. Si decide modificar un sobre aleatoriamente lo estaría impugnando, pero como el usuario tiene como ticket un \textbf{hash} de ese sobre, sabría que su voto fue modificado y podría denunciarlo. Además, como no puede leer los sobres, cualquier ataque de este tipo sería completamente aleatorio y no beneficiaría a ningún partido (en el caso de que el votante no denuncie a la urna).

\subsubsection{Mover un voto válido de una elección a otra}
La urna no puede utilizar una boleta de una votación en otra, porque las boletas firmadas por la mesa contienen el ID de la votación. Además de que la opción tendría que ser válida en la nueva elección.

\subsubsection{Agregar o sacar votos}
La urna tiene que almacenar los $R_M \bigl( U_U \left( S_{{VU}_i} \right) + \text{ID}_V \bigr)$ recibidos en el paso 2, cuya cantidad debe ser la misma que la cantidad de sobres y de comprobantes de mesa. Si saca un sobre, el votante puede darse cuenta por lo explicado en la subsección \ref{modif_voto}. Si agrega un sobre, no va a poder generar un secreto $S_{VU}$ encriptado y firmado.

\subsubsection{Saber que votó una persona}
La urna no tiene información que relacione $S_{{VU}_i}$ con el DNI de la persona, y tampoco puede abrir los sobres.

\subsubsection{Anular las elecciones}
Si la urna está fuera de servicio o si decide no contestar mensajes de los votantes, las personas que quieran depositar su sobre no van a poder y les va a aparecer un mensaje para que planteen una queja a las autoridades, pero esto no anula las elecciones (ver restricciones del protocolo).
Lo mismo sucede si decide enviarle un comprobante incorrecto.

\subsection{Ataques cometidos por un Votante}
\subsubsection{Anular las elecciones}
Una persona puede ir a quejarse con las autoridades diciendo que su voto no fue tomado en cuenta o que no lo dejan votar, pero esto no anula las elecciones (ver restricciones del protocolo).

\subsubsection{Votar varias veces}
Una persona no puede votar varias veces porque sólo tiene un $S_{{VU}_i}$ válido.

\subsection{Ataques cometidos por una persona intermedia}
\subsubsection{Robarle la identidad a un votante}
Es el deber de cada votante asegurar su clave privada. En caso de perderla tiene que notificar a las autoridades. Si no lo hiciera, una persona podría votar en su nombre.
La persona intermedia no puede leer los mensajes transmitidos porque no posee ninguna de las claves privadas (ni la de los votantes, ni la de la mesa o urna).

\subsubsection{Anular las elecciones}
Una persona que físicamente pueda meterse en el medio de la comunicación podría generar paquetes aleatoriamente, pero esto no anularía las elecciones (ver restricciones del protocolo).

\section{Vulnerabilidades y restricciones conocidas}
El desarrollo informático del protocolo no considera en profundidad ataques del estilo \emph{anular las elecciones} ejemplificado en los distintos tipos de ataque. Ante cualquier problema en el que al usuario se le requiera plantear una queja ante las autoridades (o él mismo mienta y decida hacerlo), las autoridades deben analizar el problema y resolverlo \emph{localizadamente}. Esto quiere decir que son problemas individuales a ser tratados fuera del protocolo, pero no afectan a la totalidad de la votación.


\section{Implementación}

\subsection{Arquitectura}
El sistema consta de dos aplicaciones servidor, la mesa y la urna, quienes atienden conexiones de votantes que utilizan un programa cliente, que puede ser descargado desde sitio oficial de las elecciones. En el mismo paquete, el votante estará descargando:

\begin{itemize}
 \item Claves públicas de la mesa y la urna.
 \item Direcciones IP y puertos necesarios de los servidores de mesa y urna.
 \item Padrón electoral y claves públicas de todos los votantes.
 \item Lista de las votaciones disponibles junto con las claves públicas de las opciones de voto de las mismas.
\end{itemize}

Ambos servidores utilizan su propia base de datos para guardar toda la información necesaria para el correcto funcionamiento, como boletas y comprobantes. Tanto los servidores como el cliente pueden ejecutarse en cualquier host y a través de Internet. Sin embargo, es recomendado que tanto las bases de datos como los servidores se ejecuten sobre distintos hosts. Una configuración óptima sería ejecutar cada servidor en una red distinta, con su respectiva base de datos en el mismo host.

\subsection{Funcionamiento}
Para iniciar una votación, los dos servidores deben estar ejecutándose y deben estar configurados correctamente (con las votaciones, opciones y votantes cargados), todo como se lo especifica en la sección \emph{Instalación}. 

De acuerdo a lo establecido por el diseño del protocolo, el servidor de mesa aguarda las conexiones iniciales de los votantes. Al recibir un mensaje de un votante identificándose, se crea un thread para atenderlo, iniciando todo el proceso de votación. Lo mismo sucede en la urna al ser notificada del arrivo del votante. Se establecen conexiones entre votante, mesa y urna, y de allí en más se llevan a cabo todos los pasos que el protocolo define, utilizando encriptación asimétrica y firmas.

Una vez concluida la votación se procede a efectuar el conteo de votos con una aplicación externa que requiere el uso de ambas bases de datos. Este programa desencripta cada sobre guardado en la base de la urna para saber qué boleta se encuentra dentro, y contabilizarla, chequeando a su vez contra los comprobantes de la mesa. Para hacer la apertura de sobres cuenta con las claves privadas de todas las opciones de voto de la votación en cuestión.

\subsection{Bases de la implementación}
Para la realización de este sistema se eligió el lenguaje de programación \emph{Java} dada su gran portabilidad, numerosas bibliotecas y facilidad de mantenimiento. Como base de datos se utiliza \emph{Oracle 10g}, pero resulta de escasa complejidad la modificación del sistema con el fin de hacer uso de cualquier otro motor de base de datos, tanto comercial como de código libre.

Con respecto a la parte criptográfica, se utiliza \emph{RSA de 1024 bits} para la encriptación asimétrica y firmado, mientras que se hace uso de \emph{SHA de 256 bits} para cuestiones de hashing.

\subsection{Instalación}
Para poder comenzar a hacer uso del sistema se debe disponer del directorio principal del proyecto y proceder a los siguientes pasos:

\begin{enumerate}
\item Importar el proyecto en Eclipse como un \verb#Java Project From Existing Ant Buildfile#, cuyo antfile debe ser \verb#/build.xml#.
\item Ejecutar las tareas ANT \verb#Build# y \verb#CreaJars#.
\item Disponer de una conexión a la base de datos \emph{Oracle 10g} en el puerto 11521 de \verb#localhost#. Por ejemplo, utilizando el comando \verb#$ ssh -L11521:localhost:1521 usuario@eiffel.itba.edu.ar#.
\item Ubicarse en el directorio build del proyecto.
\item Ejecutar \verb#java -jar genpadron ../resources/votantes/roles.txt ../resources/votacion/votaciones.txt#. Esto genera el padrón de votación con los archivos de entrada.
\item Ejecutar el servidor de MesaApp (en el caso de interpretar a la mesa) con el comando \verb#java -jar mesa.jar#.
\item Ejecutar el servidor de UrnaApp (en el caso de interpretar a la urna) con el comando \verb#java -jar urna.jar#..
\item Ejecutar el cliente de VotanteApp (en el caso de interpretar al votante) con el comando \verb#java -jar votante.jar#..
\end{enumerate}

Para realizar luego el conteo se debe ejecutar Contador pasándole como argumento el ID de la votación que se desea contabilizar.  Esto se hará con el comando \verb#java -jar contador.jar {votacion1}#.

Los archivos necesarios para cada programa son los siguientes (todos bajo el directorio \verb#resources#):

Para todos los programas:
\begin{itemize}
\item \verb#general#
\item \verb#votacion/*publica.key#
\item \verb#votantes/*publica.key#
\end{itemize}

Para la mesa:
\begin{itemize}
\item \verb#mesa#
\end{itemize}

Para la urna:
\begin{itemize}
\item \verb#urna#
\end{itemize}

Para el contador:
\begin{itemize}
\item \verb#votacion/*privada.key#
\end{itemize}

Para el votante:
\begin{itemize}
\item Los votantes deben incluir su clave privada en el directorio \verb#resources/votacion/#.
\end{itemize}


\newpage

\tableofcontents

\begin{thebibliography}{99}
\bibitem{linksecuriteam}``Secure Electronic Voting Over The World Wide Web'', Mark A. Herschberg, \url{http://theory.csail.mit.edu/~cis/theses/herschberg/all.pdf}.
\end{thebibliography}


\end{document} 
